---
title: "使用CycleBarrier实现异步等待"
layout: post
date: 2019-07-03 00:00:00
category: Java
tags:
 - Java
 - Thread
 - Multi-thread
 - CountLatch

share: true
comments: true
---

- 可循环利用的屏障  
- 每个线程执行时，都会碰到一个屏障，直到所有线程执行结束，然后屏障便会打开，使所有线程继续往下执行

`CyclicBarrier(int parties)`和`CyclicBarrier(int parties, Runnable barrierAction)`
- 前者只需要声明需要拦截的线程数即可
- 后者还需要定义一个等待所有线程到达屏障优先执行的Runnable对象

实现原理：

在CyclicBarrier的内部定义了一个Lock对象，每当一个线程调用await方法时，将拦截的线程数减1，然后判断剩余拦截数是否为初始值parties，如果不是，进入Lock对象的条件队列等待。如果是，执行barrierAction对象的Runnable方法，然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁。
