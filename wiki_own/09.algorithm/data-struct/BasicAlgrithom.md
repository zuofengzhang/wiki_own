---
title: 数据结构之几大基本算法
layout: post
date: 2016-04-03 11:30:00
category: DataStruct
tags:
 - Java
 - DataStruct
 - algrithom

share: true
comments: true
---
# 贪心算法

一、基本概念：

所谓贪心算法是指, 在对问题求解时, 总是做出在当前看来是最好的选择. 也就是说, 不从整体最优上加以考虑, 他所做出的仅是在某种意义上的局部最优解.
贪心算法没有固定的算法框架, 算法设计的关键是贪心策略的选择. 必须注意的是, 贪心算法不是对所有问题都能得到整体最优解, 选择的贪心策略必须具备无后效性, 即某个状态以后的过程不会影响以前的状态, 只与当前状态有关.
所以对所采用的贪心策略一定要仔细分析其是否满足无后效性.

二、贪心算法的基本思路：
1. 建立数学模型来描述问题.
2. 把求解的问题分成若干个子问题.
3. 对每一子问题求解, 得到子问题的局部最优解.
4. 把子问题的解局部最优解合成原来解问题的一个解.

三、贪心算法适用的问题

贪心策略适用的前提是：局部最优策略能导致产生全局最优解.
实际上, 贪心算法适用的情况很少. 一般, 对一个问题分析是否适用于贪心算法, 可以先选择该问题下的几个实际数据进行分析, 就可做出判断.

四、贪心算法的实现框架

    从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    {
          利用可行的决策, 求出可行解的一个解元素；
    }
    由所有解元素组合成问题的一个可行解；

五、贪心策略的选择

因为用贪心算法只能通过解局部最优解的策略来达到全局最优解, 因此, 一定要注意判断问题是否适合采用贪心算法策略, 找到的解是否一定是问题的最优解.

六、例题分析

    下面是一个可以试用贪心算法解的题目, 贪心解的确不错, 可惜不是最优解.
    [背包问题]有一个背包, 背包容量是M=150. 有7个物品, 物品可以分割成任意大小.
    要求尽可能让装入背包中的物品总价值最大, 但不能超过总容量.
    物品 A  B   C  D  E  F  G
    重量 35 30 60 50 40 10 25
    价值 10 40 30 50 35 40 30
    分析：
    目标函数： ∑pi最大
    约束条件是装入的物品总重量不超过背包容量：∑wi<=M( M=150)
    （1）根据贪心的策略, 每次挑选价值最大的物品装入背包, 得到的结果是否最优？
    （2）每次挑选所占重量最小的物品装入是否能得到最优解？
    （3）每次选取单位重量价值最大的物品, 成为解本题的策略.
    值得注意的是, 贪心算法并不是完全不可以使用, 贪心策略一旦经过证明成立后, 它就是一种高效的算法.
    贪心算法还是很常见的算法之一, 这是由于它简单易行, 构造贪心策略不是很困难.
    可惜的是, 它需要证明后才能真正运用到题目的算法中.
    一般来说, 贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的.
    对于例题中的3种贪心策略, 都是无法成立（无法被证明）的, 解释如下：
    （1）贪心策略：选取价值最大者. 反例：
    W=30
    物品：A B C
    重量：28 12 12
    价值：30 20 20
    根据策略, 首先选取物品A, 接下来就无法再选取了, 可是, 选取B、C则更好.
    （2）贪心策略：选取重量最小. 它的反例与第一种策略的反例差不多.
    （3）贪心策略：选取单位重量价值最大的物品. 反例：
    W=30
    物品：A B C
    重量：28 20 10
    价值：28 20 10
    根据策略, 三种物品单位重量价值一样, 程序无法依据现有策略作出判断, 如果选择A, 则答案错误.


# 分治策略

一、基本概念

在计算机科学中, 分治法是一种很重要的算法. 字面上的解释是“分而治之”, 就是把一个复杂的问题分成两个或更多的相同或相似的子问题, 再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解, 原问题的解即子问题的解的合并. 这个技巧是很多高效算法的基础, 如排序算法(快速排序, 归并排序), 傅立叶变换(快速傅立叶变换)……

任何一个可以用计算机求解的问题所需的计算时间都与其规模有关. 问题的规模越小, 越容易直接求解, 解题所需的计算时间也越少. 例如, 对于n个元素的排序问题, 当n=1时, 不需任何计算. n=2时, 只要作一次比较即可排好序. n=3时只要作3次比较即可, …. 而当n较大时, 问题就不那么容易处理了. 要想直接解决一个规模较大的问题, 有时是相当困难的.

二、基本思想及策略

分治法的设计思想是：将一个难以直接解决的大问题, 分割成一些规模较小的相同问题, 以便各个击破, 分而治之.

分治策略是：对于一个规模为n的问题, 若该问题可以容易地解决（比如说规模n较小）则直接解决, 否则将其分解为k个规模较小的子问题, 这些子问题互相独立且与原问题形式相同, 递归地解这些子问题, 然后将各子问题的解合并得到原问题的解. 这种算法设计策略叫做分治法.

如果原问题可分割成k个子问题, 1<k≤n, 且这些子问题都可解并可利用这些子问题的解求出原问题的解, 那么这种分治法就是可行的. 由分治法产生的子问题往往是原问题的较小模式, 这就为使用递归技术提供了方便. 在这种情况下, 反复应用分治手段, 可以使子问题与原问题类型一致而其规模却不断缩小, 最终使子问题缩小到很容易直接求出其解. 这自然导致递归过程的产生. 分治与递归像一对孪生兄弟, 经常同时应用在算法设计之中, 并由此产生许多高效算法.

三、分治法适用的情况

分治法所能解决的问题一般具有以下几个特征：

- 1) 该问题的规模缩小到一定的程度就可以容易地解决
- 2) 该问题可以分解为若干个规模较小的相同问题, 即该问题具有最优子结构性质.
- 3) 利用该问题分解出的子问题的解可以合并为该问题的解；
- 4) 该问题所分解出的各个子问题是相互独立的, 即子问题之间不包含公共的子子问题.

第一条特征是绝大多数问题都可以满足的, 因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提它也是大多数问题可以满足的, 此特征反映了递归思想的应用；、

第三条特征是关键, 能否利用分治法完全取决于问题是否具有第三条特征, 如果具备了第一条和第二条特征, 而不具备第三条特征, 则可以考虑用贪心法或动态规划法.

第四条特征涉及到分治法的效率, 如果各子问题是不独立的则分治法要做许多不必要的工作, 重复地解公共的子问题, 此时虽然可用分治法, 但一般用动态规划法较好.

四、分治法的基本步骤

分治法在每一层递归上都有三个步骤：

+ step1 分解：将原问题分解为若干个规模较小, 相互独立, 与原问题形式相同的子问题；
+ step2 解决：若子问题规模较小而容易被解决则直接解, 否则递归地解各个子问题
+ step3 合并：将各个子问题的解合并为原问题的解.

它的一般的算法设计模式如下：

```
Divide-and-Conquer(P)
1. if |P|≤n0
2. then return(ADHOC(P))
3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk
4. for i←1 to k
5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi
6. T ← MERGE(y1,y2,...,yk) △ 合并子问题
7. return(T)

其中|P|表示问题P的规模；n0为一阈值, 表示当问题P的规模不超过n0时, 问题已容易直接解出, 不必再继续分解. ADHOC(P)是该分治法中的基本子算法, 用于直接解小规模的问题P. 因此, 当P的规模不超过n0时直接用算法ADHOC(P)求解. 算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法, 用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解.
```

五、分治法的复杂性分析

一个分治法将规模为n的问题分成k个规模为n／m的子问题去解. 设分解阀值n0=1, 且adhoc解规模为1的问题耗费1个单位时间. 再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间. 用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间, 则有：

` T（n）= k T(n/m)+f(n)`

通过迭代法求得方程的解：
递归方程及其解只给出n等于m的方幂时T(n)的值, 但是如果认为T(n)足够平滑, 那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度. 通常假定T(n)是单调上升的, 从而当                  mi≤n<mi+1时, T(mi)≤T(n)<T(mi+1).

六、可使用分治法求解的一些经典问题

+ （1）二分搜索
+ （2）大整数乘法
+ （3）Strassen矩阵乘法
+ （4）棋盘覆盖
+ （5）合并排序
+ （6）快速排序
+ （7）线性时间选择
+ （8）最接近点对问题
+ （9）循环赛日程表
+ （10）汉诺塔

七、依据分治法设计程序时的思维过程

实际上就是类似于数学归纳法, 找到解决本问题的求解方程公式, 然后根据方程公式设计递归程序.

1. 一定是先找到最小问题规模时的求解方法
2. 然后考虑随着问题规模增大时的求解方法
3. 找到求解的递归函数式后（各种规模或因子）, 设计递归程序即可.

# 动态规划




---

参考文献

1. [五大常用算法之三：贪心算法](http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html)
