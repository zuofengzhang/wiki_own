---
title: 腾讯面试题整理
layout: post
date: 2016-09-20 12:26:00
category: Java
tags:
 - Java
 - Job

share: false
comments: true
---

#  类加载
[参考](http://m.blog.csdn.net/article/details?id=52203406)

## 类的加载过程

一个java文件从被加载到被卸载这个生命过程，总共要经历5个阶段，JVM将类加载过程分为：
　　**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载**
（1）加载
　　首先通过一个类的全限定名来获取此类的二进制字节流；其次将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；最后在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。总的来说就是查找并加载类的二进制数据。
（2）链接：
　　验证：确保被加载类的正确性；
　　准备：为类的静态变量分配内存，并将其初始化为默认值；
　　解析：把类中的符号引用转换为直接引用；
（3）为类的静态变量赋予正确的初始值

## 类的初始化

（1）类什么时候才被初始化
　　1）创建类的实例，也就是new一个对象
　　2）访问某个类或接口的静态变量，或者对该静态变量赋值
　　3）调用类的静态方法
　　4）反射（Class.forName(“com.lyj.load”)）
　　5）初始化一个类的子类（会首先初始化子类的父类）
　　6）JVM启动时标明的启动类，即文件名和类名相同的那个类
（2）类的初始化顺序
　　1）如果这个类还没有被加载和链接，那先进行加载和链接
　　2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）
　　3）加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。
　　4）总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法

## 类的加载

　　类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。如：

![img](https://img.readitlater.com/i/img.blog.csdn.net/20160814102740856/RS/w576.jpg?&ne=1)

![img](https://img.readitlater.com/i/img.blog.csdn.net/20160814102824474/RS/w576.jpg?&ne=1)

　　类的加载的最终产品是位于堆区中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。加载类的方式有以下几种：
　　1）从本地系统直接加载
　　2）通过网络下载.class文件
　　3）从zip，jar等归档文件中加载.class文件
　　4）从专有数据库中提取.class文件
　　5）将Java源文件动态编译为.class文件（服务器）

## ClassLoader

JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：

![](https://img.readitlater.com/i/img.blog.csdn.net/20160814103048141/RS/w576.jpg)


## （1）加载器介绍

1）BootstrapClassLoader（启动类加载器）
　　负责加载`$JAVA_HOME中jre/lib/rt.jar`里所有的class，加载`System.getProperty(“sun.boot.class.path”)`所指定的路径或jar。
2）ExtensionClassLoader（标准扩展类加载器）
　　负责加载java平台中扩展功能的一些jar包，包括`$JAVA_HOME中jre/lib/*.jar`或`-Djava.ext.dirs`指定目录下的jar包。在`System.getProperty(“java.ext.dirs”)`所指定的路径或jar。
3）AppClassLoader（系统类加载器）
　　负责记载classpath中指定的jar包及目录中class
4）CustomClassLoader（自定义加载器）
　　属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。

## （2）类加载器的顺序

1）加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。
2）在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。
3）Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。

# IO

## bytebuffer以及读写切换

```java
public void fileCopy(File srcFile,File objFile) throws IOException
{
//ByteBuffer.allocate()方法分配了一段内存空间，作为缓存，allocate方法对缓存自动清零
    ByteBuffer buff = ByteBuffer.allocate(128);
    FileChannel fin = null;
    FileChannel fout = null;
    try
    {
        fin = new FileInputStream(srcFile).getChannel();
        fout = new FileOutputStream(objFile).getChannel();
        while(fin.read(buff) != -1) {
            buff.flip();
            fout.write(buff);
            buff.clear();
        }
    }catch (FileNotFoundException e){

    } finally {
        try {
            if(fin != null) {
                fin.close();
            }
            if(fout != null) {
                fout.close();
            }
        } catch(IOException e) {
            throw e;
        }
    }
}
```

在ByteBuffer对象内部定义了四个索引，分别是mark，position，limit，capacity，其中

- mark用于对当前position的标记
- position表示当前可读写的指针，如果是向ByteBuffer对象中写入一个字节，那么就会向position所指向的地址写入这个字节，如果是从ByteBuffer读出一个字节，那么就会读出position所指向的地址读出这个字节，读写完成后，position加1
- limit是可以读写的边界，当position到达limit时，就表示将ByteBuffer中的内容读完，或者将ByteBuffer写满了。
- capacity是这个ByteBuffer的容量，上面的程序中调用`ByteBuffer.allocate(128)`就表示创建了一个容量为capacity字节的ByteBuffer对象。

### ByteBuffer内部字段

byte[] buff

buff即内部用于缓存的数组。

position

当前读取的位置。

mark

为某一读过的位置做标记，便于某些时候回退到该位置。

capacity

初始化时候的容量。

limit

读写的上限，limit<=capacity。

## 操作

### put

写模式下，往buffer里写一个字节，并把postion移动一位。写模式下，一般limit与capacity相等。![bytebuffer-put](http://static.oschina.net/uploads/space/2013/0906/145012_wNAE_190591.png)

### flip

写完数据，需要开始读的时候，将postion复位到0，并将limit设为当前postion。![bytebuffer-flip](http://static.oschina.net/uploads/space/2013/0906/145641_qTuf_190591.png)

### get

从buffer里读一个字节，并把postion移动一位。上限是limit，即写入数据的最后位置。![bytebuffer-get](http://static.oschina.net/uploads/space/2013/0906/145049_jHFW_190591.png)

### clear

将position置为0，并不清除buffer内容。

![bytebuffer-clear](http://static.oschina.net/uploads/space/2013/0906/145130_5UA5_190591.png)

mark相关的方法主要是`mark()`(标记)和`reset()`(回到标记)，比较简单，就不画图了。



# newwork

## HTTP状态码

HTTP协议的状态响应码为3位整数，分为5类：

   + 100~199：表示服务器成功接收请求，但要求客户端继续提交下一次请求才能完成全部处理过程。
   + 200~299：表示服务端已成功接收请求，并完成了全部处理过程。
   + 300~399：表示客户端请求的资源已经转移到了别的位置，并向客户端提供一个新的地址，这个地址由HTTP响应消息头的location字段指定。
   + 400~499：表示客户端的请求有错误。
   + 500~599：表示服务端出现错误。



### 200

请求已成功，请求所希望的响应头或数据体将随此响应返回。

### 206

服务器已经成功处理了部分 GET 请求。标示服务器支持断点续传。

该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。
响应必须包含如下的头部域：
Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为
multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range
域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。
Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。
Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。
假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range
弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。
假如 ETag 或 Last-Modified
头部不能精确匹配的话， 则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。
任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。

### 301

被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。
如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。

### 302

请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI
的超链接及简短说明。
如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。

### 304

如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而 `文档的内容（自上次访问以来或者根据请求的条件）并没有改变` ，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。


### 404

服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。

### 500

服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。

### 503

由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。

注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。

## HTTP请求头

###　referer

HTTP Referer是header的一部分，当浏览器向web[服务器](http://baike.baidu.com/view/899.htm)发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。

1 Referer可以记录访问的来源，统计访问量，可以用来防盗链。

2 客户端用js不能篡改Referer，用一些插件什么的可以达到伪造的目的。

3 可以使用Fiddler修改Referer。

4 服务器端修改Referer，通过webClient，直接设置访问可以达到修改目的。

5 其它的一些修改Referer的方式方法。参考：[http://www.cnblogs.com/mx3000/archive/2007/12/17/1003239.html](http://www.cnblogs.com/mx3000/archive/2007/12/17/1003239.html)

6 利用Referer防止图片盗链

虽然Referer并不可靠，但用来防止图片盗链还是足够的，毕竟不是每个人都会修改客户端的配置。（一般只允许站内访问）

参考：[http://blog.csdn.net/21aspnet/article/details/6197314](http://blog.csdn.net/21aspnet/article/details/6197314)

# duboo





# java.util.concurrent包

## CountDownLatch

 [Java之CountDownLatch使用 ](http://blog.csdn.net/shihuacai/article/details/8856370)

- 将阻塞队列分离

## synchronized 与 ReteenLock 区别

[[Lock与synchronized 的区别](http://houlinyan.iteye.com/blog/1112535)](http://houlinyan.iteye.com/blog/1112535)

## CyclicBarrier

## CAS

[[聊聊并发（五）——原子操作的实现原理](http://www.infoq.com/cn/articles/atomic-operation/)](http://www.infoq.com/cn/articles/atomic-operation/)

## Atomic

AtomInteger

# web安全

## SQL注入

## XSS

## curf
